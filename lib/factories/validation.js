// Generated by CoffeeScript 1.9.3
var slice = [].slice;

module.exports.predicateToValidator = function() {
  return function(predicate, error) {
    return function(value) {
      if (predicate(value)) {
        return null;
      } else {
        return error;
      }
    };
  };
};

module.exports.schemaToValidator = function() {
  return function(schema) {
    return function(data) {
      var errors;
      errors = {};
      Object.keys(schema).forEach(function(key) {
        var error, validator;
        validator = schema[key];
        if ('function' !== typeof validator) {
          throw new Error("validator must be a function but is " + (typeof validator));
        }
        error = validator(data[key]);
        if (error != null) {
          return errors[key] = error;
        }
      });
      if (Object.keys(errors).length === 0) {
        return null;
      } else {
        return errors;
      }
    };
  };
};

module.exports.chainValidators = function() {
  return function() {
    var validators;
    validators = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(value) {
      var errors, i, len, validator;
      for (i = 0, len = validators.length; i < len; i++) {
        validator = validators[i];
        errors = validator(value);
        if (errors != null) {
          return errors;
        }
      }
      return null;
    };
  };
};

module.exports.existenceValidator = function(isjs, predicateToValidator) {
  return predicateToValidator(isjs.existy, 'must not be null or undefined');
};

module.exports.stringValidator = function(isjs, predicateToValidator, chainValidators, existenceValidator) {
  return chainValidators(existenceValidator, predicateToValidator(isjs.string, 'must be a string'));
};

module.exports.stringNotEmptyValidator = function(isjs, predicateToValidator, chainValidators, stringValidator) {
  return chainValidators(stringValidator, predicateToValidator(isjs.not.empty, 'must not be the empty string'));
};

module.exports.emailValidator = function(isjs, predicateToValidator, chainValidators, stringValidator) {
  return chainValidators(stringValidator, predicateToValidator(isjs.email, 'must be an email address'));
};

module.exports.stringMinLengthValidator = function(predicateToValidator, chainValidators, stringNotEmptyValidator) {
  return function(min) {
    var predicate;
    predicate = function(value) {
      return value.length >= min;
    };
    return chainValidators(stringNotEmptyValidator, predicateToValidator(predicate, "must be at least " + min + " characters long"));
  };
};

module.exports.optionalValidator = function(isjs) {
  return function(validator) {
    return function(value) {
      if (isjs.undefined(value)) {
        return;
      }
      return validator(value);
    };
  };
};

module.exports.stringMinLengthValidator = function(predicateToValidator, chainValidators, stringNotEmptyValidator) {
  return function(min) {
    var predicate;
    predicate = function(value) {
      return value.length >= min;
    };
    return chainValidators(stringNotEmptyValidator, predicateToValidator(predicate, "must be at least " + min + " characters long"));
  };
};

module.exports.loginValidator = function(schemaToValidator, stringNotEmptyValidator, stringMinLengthValidator) {
  return schemaToValidator({
    username: stringNotEmptyValidator,
    password: stringMinLengthValidator(8)
  });
};

module.exports.userInsertValidator = function(schemaToValidator, stringNotEmptyValidator, stringMinLengthValidator, stringValidator, emailValidator, Promise, firstUserWhereName, firstUserWhereEmail) {
  var validator;
  validator = schemaToValidator({
    name: stringNotEmptyValidator,
    password: stringMinLengthValidator(8),
    email: emailValidator,
    rights: stringValidator
  });
  return function(user) {
    return Promise.resolve(validator(user)).then(function(errors) {
      if ((errors != null ? errors.name : void 0) != null) {
        return errors;
      }
      return firstUserWhereName(user.name).then(function(withSameName) {
        if (withSameName != null) {
          if (errors == null) {
            errors = {};
          }
          errors.name = 'taken';
        }
        return errors;
      });
    }).then(function(errors) {
      if ((errors != null ? errors.email : void 0) != null) {
        return errors;
      }
      return firstUserWhereEmail(user.email).then(function(withSameEmail) {
        if (withSameEmail != null) {
          if (errors == null) {
            errors = {};
          }
          errors.email = 'taken';
        }
        return errors;
      });
    });
  };
};

module.exports.selfUpdateValidator = function(schemaToValidator, optionalValidator, stringNotEmptyValidator, stringMinLengthValidator, emailValidator, firstUserWhereNameAndNotId, firstUserWhereEmailAndNotId) {
  var validator;
  validator = schemaToValidator({
    name: optionalValidator(stringNotEmptyValidator),
    password: optionalValidator(stringMinLengthValidator(8)),
    email: optionalValidator(emailValidator),
    rights: function(value) {
      if (value != null) {
        return 'you are not allowed to set your own rights';
      }
    }
  });
  return function(user, id) {
    return Promise.resolve(validator(user)).then(function(errors) {
      if ((errors != null ? errors.name : void 0) != null) {
        return errors;
      }
      return firstUserWhereNameAndNotId(user.name, id).then(function(withSameName) {
        if (withSameName != null) {
          if (errors == null) {
            errors = {};
          }
          errors.name = 'taken';
        }
        return errors;
      });
    }).then(function(errors) {
      if ((errors != null ? errors.email : void 0) != null) {
        return errors;
      }
      return firstUserWhereEmailAndNotId(user.email, id).then(function(withSameEmail) {
        if (withSameEmail != null) {
          if (errors == null) {
            errors = {};
          }
          errors.email = 'taken';
        }
        return errors;
      });
    });
  };
};

module.exports.userUpdateValidator = function(schemaToValidator, optionalValidator, stringNotEmptyValidator, stringMinLengthValidator, stringValidator, emailValidator, firstUserWhereNameAndNotId, firstUserWhereEmailAndNotId) {
  var validator;
  validator = schemaToValidator({
    name: optionalValidator(stringNotEmptyValidator),
    password: optionalValidator(stringMinLengthValidator(8)),
    email: optionalValidator(emailValidator),
    rights: optionalValidator(stringValidator)
  });
  return function(user, id) {
    return Promise.resolve(validator(user)).then(function(errors) {
      if ((errors != null ? errors.name : void 0) != null) {
        return errors;
      }
      return firstUserWhereNameAndNotId(user.name, id).then(function(withSameName) {
        if (withSameName != null) {
          if (errors == null) {
            errors = {};
          }
          errors.name = 'taken';
        }
        return errors;
      });
    }).then(function(errors) {
      if ((errors != null ? errors.email : void 0) != null) {
        return errors;
      }
      return firstUserWhereEmailAndNotId(user.email, id).then(function(withSameEmail) {
        if (withSameEmail != null) {
          if (errors == null) {
            errors = {};
          }
          errors.email = 'taken';
        }
        return errors;
      });
    });
  };
};
